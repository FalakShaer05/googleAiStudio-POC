<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Photo Character Transformer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 2rem 0;
        }
        
        .main-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            margin: 0 auto;
            max-width: 1200px;
            padding: 2rem;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        
        .step-card {
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            background: white;
        }
        
        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f0f0;
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8e8e8;
        }
        
        .character-card {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            background: #f8f9fa;
        }
        
        .character-info {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .character-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            margin-right: 1rem;
        }
        
        .preview-image {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin: 1rem 0;
        }
        
        #groupPhotoImg {
            max-width: 500px;
            max-height: 400px;
            width: auto;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 25px;
            font-weight: 600;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.3rem;
        }
        
        .alert {
            border-radius: 10px;
            border: none;
        }
        
        .hidden {
            display: none;
        }
        
        .character-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 10px;
            margin: 0.5rem 0;
        }
        
        .final-preview {
            max-width: 100%;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            margin: 1rem 0;
        }
        
        .positioning-canvas-wrapper {
            position: relative;
            background: #f8f9fa;
        }
        
        #positioningCanvas {
            cursor: move;
            touch-action: none;
        }
        
        .character-dragging {
            opacity: 0.7;
            cursor: grabbing !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-container">
            <div class="header">
                <h1><i class="fas fa-users me-2"></i>Group Photo Character Transformer</h1>
                <p class="mb-0">Transform individual characters from group photos with custom prompts</p>
                <a href="/" class="btn btn-light mt-3">
                    <i class="fas fa-arrow-left me-2"></i>Back to Main
                </a>
            </div>

            <!-- Step 1: Upload Group Photo -->
            <div class="step-card" id="step1">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3 class="mb-0">Upload Group Photo</h3>
                </div>
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt fa-3x mb-3 text-primary"></i>
                    <h5>Drag & Drop or Click to Upload</h5>
                    <p class="text-muted">Upload a group photo containing multiple people</p>
                    <input type="file" id="groupPhotoInput" accept="image/*" class="d-none">
                </div>
                <div id="groupPhotoPreview" class="hidden mt-3">
                    <img id="groupPhotoImg" class="preview-image" alt="Group Photo Preview">
                    <button class="btn btn-primary mt-2" onclick="detectCharacters()">
                        <i class="fas fa-search me-2"></i>Detect Characters
                    </button>
                </div>
            </div>

            <!-- Step 2: Character Transformation Prompts -->
            <div class="step-card hidden" id="step2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3 class="mb-0">Transform Characters</h3>
                </div>
                <p class="text-muted mb-3">Review detected characters and enter a custom prompt for each to transform them</p>
                <div id="characterPrompts"></div>
                <button class="btn btn-primary mt-3" onclick="transformAllCharacters()">
                    <i class="fas fa-magic me-2"></i>Transform All Characters
                </button>
            </div>

            <!-- Step 3: Background Selection & Character Positioning -->
            <div class="step-card hidden" id="step3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3 class="mb-0">Select Background & Position Characters</h3>
                </div>
                <div class="mb-3">
                    <label class="form-label">Background Image (Optional)</label>
                    <input type="file" id="backgroundInput" accept="image/*" class="form-control" onchange="handleBackgroundChange()">
                    <small class="text-muted">Leave empty to use a default background</small>
                </div>
                <div id="backgroundPreview" class="hidden mt-3">
                    <img id="backgroundImg" class="preview-image" alt="Background Preview">
                </div>
                
                <!-- Character Positioning Canvas -->
                <div id="positioningSection" class="hidden mt-4">
                    <h5 class="mb-3">Adjust Character Positions & Sizes</h5>
                    <p class="text-muted small mb-3">Drag characters to position them. Use the scale controls below to resize each character.</p>
                    <div class="positioning-canvas-wrapper mb-3" style="border: 2px solid #e0e0e0; border-radius: 10px; overflow: hidden; background: #f8f9fa;">
                        <canvas id="positioningCanvas" width="800" height="600" style="max-width: 100%; height: auto; display: block;"></canvas>
                    </div>
                    
                    <!-- Character Scale Controls -->
                    <div id="characterScaleControls" class="mb-3">
                        <h6 class="mb-2">Character Sizes:</h6>
                        <div id="scaleControlsContainer" class="d-flex flex-wrap gap-3"></div>
                    </div>
                    
                    <div class="d-flex gap-2 mb-3">
                        <button class="btn btn-outline-secondary" onclick="resetCharacterPositions()">
                            <i class="fas fa-redo me-2"></i>Reset Positions
                        </button>
                        <button class="btn btn-outline-primary" onclick="autoArrangeCharacters()">
                            <i class="fas fa-magic me-2"></i>Auto Arrange
                        </button>
                    </div>
                </div>
                
                <button class="btn btn-primary mt-3" onclick="compositeCharacters()">
                    <i class="fas fa-layer-group me-2"></i>Composite All Characters
                </button>
            </div>

            <!-- Step 4: Final Result -->
            <div class="step-card hidden" id="step4">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <h3 class="mb-0">Final Result</h3>
                </div>
                <div id="finalResult"></div>
                <button class="btn btn-primary mt-3" onclick="downloadResult()">
                    <i class="fas fa-download me-2"></i>Download Final Image
                </button>
            </div>

            <!-- Loading Indicator -->
            <div class="loading" id="loading">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-3" id="loadingText">Processing...</p>
            </div>

            <!-- Error Alert -->
            <div class="alert alert-danger hidden" id="errorAlert" role="alert">
                <i class="fas fa-exclamation-triangle me-2"></i>
                <span id="errorMessage"></span>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let groupPhotoFile = null;
        let groupPhotoPath = null;
        let groupPhotoFilename = null;
        let detectedCharacters = [];
        let transformedCharacters = [];
        let finalCompositeUrl = null;
        
        // Character positioning state
        let positioningCanvas = null;
        let positioningCtx = null;
        let positioningState = {
            backgroundImg: null,
            characterImgs: [],
            positions: [],
            scales: [], // Scale factor for each character (default 1.0)
            draggingIndex: null,
            dragOffset: { x: 0, y: 0 }
        };

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const groupPhotoInput = document.getElementById('groupPhotoInput');
        const groupPhotoPreview = document.getElementById('groupPhotoPreview');
        const groupPhotoImg = document.getElementById('groupPhotoImg');

        uploadArea.addEventListener('click', () => groupPhotoInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        groupPhotoInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        function handleFileSelect(file) {
            groupPhotoFile = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                groupPhotoImg.src = e.target.result;
                groupPhotoPreview.classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        }

        async function detectCharacters() {
            if (!groupPhotoFile) {
                showError('Please upload a group photo first');
                return;
            }

            showLoading('Detecting characters in the photo...');
            hideError();

            const formData = new FormData();
            formData.append('image', groupPhotoFile);

            try {
                const response = await fetch('/detect-characters', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    detectedCharacters = data.characters;
                    groupPhotoFilename = data.group_photo_filename; // Store filename for later use
                    displayCharacterPrompts(); // Show characters in transform section
                    document.getElementById('step2').classList.remove('hidden');
                    hideLoading();
                } else {
                    showError(data.error || 'Character detection failed');
                    hideLoading();
                }
            } catch (error) {
                showError('Error detecting characters: ' + error.message);
                hideLoading();
            }
        }

        function displayCharacterPrompts() {
            const promptsContainer = document.getElementById('characterPrompts');
            promptsContainer.innerHTML = '';

            detectedCharacters.forEach(char => {
                const promptCard = document.createElement('div');
                promptCard.className = 'character-card';
                
                // Build preview image HTML if available
                let previewHtml = '';
                if (char.preview_url) {
                    previewHtml = `
                        <div class="text-center mb-3">
                            <img src="${char.preview_url}" 
                                 class="character-preview" 
                                 alt="Character ${char.character_number} Preview"
                                 style="max-width: 200px; max-height: 250px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                            <p class="text-muted small mt-2">Character ${char.character_number}</p>
                        </div>
                    `;
                }
                
                promptCard.innerHTML = `
                    <div class="row">
                        <div class="col-md-3">
                            ${previewHtml}
                        </div>
                        <div class="col-md-9">
                            <div class="character-info mb-2">
                                <span class="character-badge">Character ${char.character_number}</span>
                            </div>
                            <div class="mb-2">
                                <p class="mb-2"><strong>Description:</strong> ${char.description}</p>
                                <div class="row mb-2">
                                    <div class="col-6">
                                        <small><strong>Position:</strong> ${char.position} | <strong>Age:</strong> ${char.age}</small>
                                    </div>
                                    <div class="col-6">
                                        <small><strong>Gender:</strong> ${char.gender || 'unknown'} | <strong>Role:</strong> ${char.role || 'unknown'}</small>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Transform Character To</label>
                                <select class="form-select" 
                                        id="prompt_${char.character_number}">
                                    <option value="">Select a transformation...</option>
                                    <option value="musician">Musician</option>
                                    <option value="painter">Painter</option>
                                    <option value="footballer">Footballer</option>
                                    <option value="cowboy">Cowboy</option>
                                    <option value="artist">Artist</option>
                                </select>
                                <small class="text-muted">Choose how to transform this character</small>
                            </div>
                        </div>
                    </div>
                `;
                promptsContainer.appendChild(promptCard);
            });
        }

        async function transformAllCharacters() {
            if (detectedCharacters.length === 0) {
                showError('No characters detected. Please detect characters first.');
                return;
            }

            if (!groupPhotoFile) {
                showError('Please upload a group photo first.');
                return;
            }

            showLoading('Transforming characters... This may take a few minutes.');
            hideError();
            transformedCharacters = [];

            // Transform each character
            for (const char of detectedCharacters) {
                const promptSelect = document.getElementById(`prompt_${char.character_number}`);
                const selectedValue = promptSelect ? promptSelect.value.trim() : '';

                if (!selectedValue) {
                    console.warn(`No transformation selected for character ${char.character_number}, skipping`);
                    continue;
                }
                
                // Map dropdown value to transformation type
                const prompt = getTransformationPrompt(selectedValue);

                try {
                    const formData = new FormData();
                    // Use stored filename if available, otherwise upload file
                    if (groupPhotoFilename) {
                        formData.append('group_photo_filename', groupPhotoFilename);
                    } else {
                        formData.append('group_photo', groupPhotoFile);
                    }
                    formData.append('character_number', char.character_number);
                    formData.append('transformation_type', selectedValue);
                    formData.append('prompt', prompt);
                    formData.append('character_description', char.description);

                    const response = await fetch('/transform-character', {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();

                    if (data.success) {
                        transformedCharacters.push({
                            character_number: char.character_number,
                            filename: data.output_filename,
                            url: data.output_url
                        });
                    } else {
                        console.error(`Failed to transform character ${char.character_number}:`, data.error);
                    }
                } catch (error) {
                    console.error(`Error transforming character ${char.character_number}:`, error);
                }
            }

            hideLoading();

            if (transformedCharacters.length === 0) {
                showError('No characters were successfully transformed. Please check your prompts and try again.');
                return;
            }

            // Display transformed characters
            displayTransformedCharacters();
            document.getElementById('step3').classList.remove('hidden');
            
            // Initialize positioning canvas after a short delay to ensure images are loaded
            setTimeout(() => {
                initPositioningCanvas();
            }, 500);
        }

        function displayTransformedCharacters() {
            const promptsContainer = document.getElementById('characterPrompts');
            transformedCharacters.forEach(char => {
                const charCard = promptsContainer.querySelector(`#prompt_${char.character_number}`)?.closest('.character-card');
                if (charCard) {
                    const previewDiv = document.createElement('div');
                    previewDiv.className = 'mt-2';
                    previewDiv.innerHTML = `
                        <img src="${char.url}" class="character-preview" alt="Character ${char.character_number}">
                        <small class="text-success d-block mt-1">
                            <i class="fas fa-check-circle me-1"></i>Transformed successfully
                        </small>
                    `;
                    charCard.appendChild(previewDiv);
                }
            });
        }

        async function compositeCharacters() {
            if (transformedCharacters.length === 0) {
                showError('No transformed characters available. Please transform characters first.');
                return;
            }

            showLoading('Compositing characters onto background...');
            hideError();

            const formData = new FormData();
            transformedCharacters.forEach(char => {
                formData.append('character_files[]', char.filename);
            });

            // Handle background if provided
            const backgroundInput = document.getElementById('backgroundInput');
            if (backgroundInput.files.length > 0) {
                formData.append('background', backgroundInput.files[0]);
            }

            // Use positions from positioning canvas if available, otherwise use defaults
            let positions = [];
            if (positioningState.positions && positioningState.positions.length > 0 && positioningState.backgroundImg && positioningCanvas) {
                // Convert canvas positions to actual image positions
                const scaleX = positioningState.backgroundImg.width / positioningCanvas.width;
                const scaleY = positioningState.backgroundImg.height / positioningCanvas.height;
                
                positions = positioningState.positions.map((pos, index) => ({
                    x: pos.x * scaleX,
                    y: pos.y * scaleY,
                    scale: positioningState.scales[index] || 1.0
                }));
            } else {
                // Use default positions (bottom-aligned, distributed)
                positions = transformedCharacters.map((char, index) => ({
                    character_number: char.character_number,
                    x: null, // Will be calculated server-side
                    y: null
                }));
            }
            formData.append('positions', JSON.stringify(positions));

            try {
                const response = await fetch('/composite-characters', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    finalCompositeUrl = data.output_url;
                    displayFinalResult(data.output_url);
                    document.getElementById('step4').classList.remove('hidden');
                    hideLoading();
                } else {
                    showError(data.error || 'Compositing failed');
                    hideLoading();
                }
            } catch (error) {
                showError('Error compositing characters: ' + error.message);
                hideLoading();
            }
        }

        function displayFinalResult(url) {
            const finalResult = document.getElementById('finalResult');
            finalResult.innerHTML = `
                <img src="${url}" class="final-preview" alt="Final Composite">
                <p class="text-success mt-3">
                    <i class="fas fa-check-circle me-2"></i>All characters have been successfully composited!
                </p>
            `;
        }

        // Map dropdown values to strict transformation prompts
        function getTransformationPrompt(transformationType) {
            const prompts = {
                'musician': 'Transform this character into a professional musician. Show them holding a musical instrument (guitar, piano, violin, or drums). They should be dressed in stylish musician attire, with a confident and artistic pose. The character should look like a talented musician performing or ready to perform. Maintain the character\'s facial features and body structure, but change their clothing and add appropriate musical elements. The background must be solid white.',
                'painter': 'Transform this character into a professional painter or artist. Show them holding a paintbrush and palette, or standing in front of an easel with a canvas. They should be wearing an artist\'s smock or apron with paint stains. The character should have an artistic, creative appearance with paint on their hands or clothes. Maintain the character\'s facial features and body structure, but change their clothing to artist attire. The background must be solid white.',
                'footballer': 'Transform this character into a professional footballer (soccer player). Show them wearing a football jersey, shorts, and cleats. They should be in a dynamic football pose, either kicking a ball or in a ready-to-play stance. The character should look athletic and sporty. Maintain the character\'s facial features and body structure, but change their clothing to football gear and add a football if appropriate. The background must be solid white.',
                'cowboy': 'Transform this character into a classic cowboy. Show them wearing a cowboy hat, boots, jeans, and a western shirt or jacket. They should have a rugged, western appearance. Optionally include cowboy accessories like a belt buckle or bandana. The character should look like they belong in the Wild West. Maintain the character\'s facial features and body structure, but change their clothing to cowboy attire. The background must be solid white.',
                'artist': 'Transform this character into a creative artist. Show them in an artistic setting with creative elements like brushes, canvases, or art supplies. They should be wearing creative, bohemian-style clothing that reflects their artistic personality. The character should have an expressive, creative appearance. Maintain the character\'s facial features and body structure, but change their clothing to artistic, creative attire. The background must be solid white.'
            };
            return prompts[transformationType] || '';
        }

        function downloadResult() {
            if (finalCompositeUrl) {
                const link = document.createElement('a');
                link.href = finalCompositeUrl;
                link.download = 'group_composite.png';
                link.click();
            }
        }

        function showLoading(text = 'Processing...') {
            document.getElementById('loading').classList.add('active');
            document.getElementById('loadingText').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loading').classList.remove('active');
        }

        function showError(message) {
            document.getElementById('errorAlert').classList.remove('hidden');
            document.getElementById('errorMessage').textContent = message;
        }

        function hideError() {
            document.getElementById('errorAlert').classList.add('hidden');
        }

        // Character positioning functions
        function initPositioningCanvas() {
            positioningCanvas = document.getElementById('positioningCanvas');
            if (!positioningCanvas) return;
            
            positioningCtx = positioningCanvas.getContext('2d');
            const positioningSection = document.getElementById('positioningSection');
            
            // Load background image if available
            const backgroundInput = document.getElementById('backgroundInput');
            if (backgroundInput.files.length > 0) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    positioningState.backgroundImg = new Image();
                    positioningState.backgroundImg.onload = () => {
                        setupPositioningCanvas();
                        positioningSection.classList.remove('hidden');
                    };
                    positioningState.backgroundImg.src = e.target.result;
                };
                reader.readAsDataURL(backgroundInput.files[0]);
            } else {
                // Use default background
                positioningState.backgroundImg = new Image();
                positioningState.backgroundImg.onload = () => {
                    setupPositioningCanvas();
                    positioningSection.classList.remove('hidden');
                };
                // Create a default colored background
                const canvas = document.createElement('canvas');
                canvas.width = 1920;
                canvas.height = 1080;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#87CEEB'; // lightblue
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                positioningState.backgroundImg.src = canvas.toDataURL();
            }
        }
        
        function setupPositioningCanvas() {
            if (!positioningCanvas || !positioningCtx) return;
            
            // Set canvas size based on background
            const bgImg = positioningState.backgroundImg;
            const maxWidth = 800;
            const maxHeight = 600;
            const scale = Math.min(maxWidth / bgImg.width, maxHeight / bgImg.height, 1);
            
            positioningCanvas.width = bgImg.width * scale;
            positioningCanvas.height = bgImg.height * scale;
            
            // Load character images
            positioningState.characterImgs = [];
            positioningState.positions = [];
            positioningState.scales = [];
            
            const baseScale = Math.min(maxWidth / bgImg.width, maxHeight / bgImg.height, 1);
            
            transformedCharacters.forEach((char, index) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    positioningState.characterImgs.push({
                        img: img,
                        originalWidth: img.width,
                        originalHeight: img.height,
                        baseScale: baseScale
                    });
                    
                    // Initialize positions (distribute horizontally)
                    const initialScale = 1.0;
                    const scaledWidth = img.width * baseScale * initialScale;
                    const scaledHeight = img.height * baseScale * initialScale;
                    const spacing = positioningCanvas.width / (transformedCharacters.length + 1);
                    const x = spacing * (index + 1) - scaledWidth / 2;
                    const y = positioningCanvas.height - scaledHeight - 50;
                    
                    positioningState.positions.push({ x, y });
                    positioningState.scales.push(initialScale);
                    
                    // Draw when all images are loaded
                    if (positioningState.characterImgs.length === transformedCharacters.length) {
                        drawPositioningCanvas();
                        updateScaleControls();
                    }
                };
                img.src = char.url;
            });
            
            // Add event listeners for dragging
            positioningCanvas.addEventListener('mousedown', startDrag);
            positioningCanvas.addEventListener('mousemove', (e) => {
                if (positioningState.draggingIndex !== null) {
                    drag(e);
                } else {
                    // Update cursor on hover to show draggable areas
                    const pos = getMousePos(e);
                    let found = false;
                    for (let i = positioningState.characterImgs.length - 1; i >= 0; i--) {
                        const charData = positioningState.characterImgs[i];
                        const charPos = positioningState.positions[i];
                        const scale = positioningState.scales[i] || 1.0;
                        const scaledWidth = charData.originalWidth * charData.baseScale * scale;
                        const scaledHeight = charData.originalHeight * charData.baseScale * scale;
                        if (pos.x >= charPos.x && pos.x <= charPos.x + scaledWidth &&
                            pos.y >= charPos.y && pos.y <= charPos.y + scaledHeight) {
                            positioningCanvas.style.cursor = 'grab';
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        positioningCanvas.style.cursor = 'default';
                    }
                }
            });
            positioningCanvas.addEventListener('mouseup', endDrag);
            positioningCanvas.addEventListener('mouseleave', endDrag);
            positioningCanvas.addEventListener('touchstart', handleTouchStart);
            positioningCanvas.addEventListener('touchmove', handleTouchMove);
            positioningCanvas.addEventListener('touchend', handleTouchEnd);
        }
        
        function drawPositioningCanvas() {
            if (!positioningCtx || !positioningState.backgroundImg) return;
            
            // Clear canvas
            positioningCtx.clearRect(0, 0, positioningCanvas.width, positioningCanvas.height);
            
            // Draw background
            positioningCtx.drawImage(
                positioningState.backgroundImg,
                0, 0,
                positioningCanvas.width,
                positioningCanvas.height
            );
            
            // Draw characters
            positioningState.characterImgs.forEach((charData, index) => {
                const pos = positioningState.positions[index];
                const scale = positioningState.scales[index] || 1.0;
                if (pos && charData.img) {
                    const scaledWidth = charData.originalWidth * charData.baseScale * scale;
                    const scaledHeight = charData.originalHeight * charData.baseScale * scale;
                    
                    positioningCtx.drawImage(
                        charData.img,
                        pos.x,
                        pos.y,
                        scaledWidth,
                        scaledHeight
                    );
                    
                    // Draw border for selected character
                    if (positioningState.draggingIndex === index) {
                        positioningCtx.strokeStyle = '#667eea';
                        positioningCtx.lineWidth = 3;
                        positioningCtx.strokeRect(
                            pos.x - 2,
                            pos.y - 2,
                            scaledWidth + 4,
                            scaledHeight + 4
                        );
                    }
                }
            });
        }
        
        function getMousePos(e) {
            const rect = positioningCanvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getTouchPos(e) {
            const rect = positioningCanvas.getBoundingClientRect();
            const touch = e.touches[0] || e.changedTouches[0];
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }
        
        function startDrag(e) {
            const pos = getMousePos(e);
            if (findCharacterAtPosition(pos)) {
                e.preventDefault();
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            findCharacterAtPosition(pos);
        }
        
        function findCharacterAtPosition(pos) {
            // Check from top to bottom (last drawn = topmost)
            for (let i = positioningState.characterImgs.length - 1; i >= 0; i--) {
                const charData = positioningState.characterImgs[i];
                const charPos = positioningState.positions[i];
                const scale = positioningState.scales[i] || 1.0;
                const scaledWidth = charData.originalWidth * charData.baseScale * scale;
                const scaledHeight = charData.originalHeight * charData.baseScale * scale;
                
                if (pos.x >= charPos.x && pos.x <= charPos.x + scaledWidth &&
                    pos.y >= charPos.y && pos.y <= charPos.y + scaledHeight) {
                    positioningState.draggingIndex = i;
                    positioningState.dragOffset = {
                        x: pos.x - charPos.x,
                        y: pos.y - charPos.y
                    };
                    positioningCanvas.style.cursor = 'grabbing';
                    drawPositioningCanvas();
                    return true;
                }
            }
            return false;
        }
        
        function drag(e) {
            if (positioningState.draggingIndex === null) return;
            
            const pos = getMousePos(e);
            const index = positioningState.draggingIndex;
            const charData = positioningState.characterImgs[index];
            
            // Allow free movement - characters can be positioned anywhere, even partially off-screen
            // Only constrain to prevent complete off-screen positioning
            const scale = positioningState.scales[index] || 1.0;
            const scaledWidth = charData.originalWidth * charData.baseScale * scale;
            const scaledHeight = charData.originalHeight * charData.baseScale * scale;
            const newX = pos.x - positioningState.dragOffset.x;
            const newY = pos.y - positioningState.dragOffset.y;
            
            // Allow positioning anywhere, but keep at least part of character visible
            positioningState.positions[index] = {
                x: Math.max(-scaledWidth * 0.8, Math.min(newX, positioningCanvas.width - scaledWidth * 0.2)),
                y: Math.max(-scaledHeight * 0.8, Math.min(newY, positioningCanvas.height - scaledHeight * 0.2))
            };
            
            drawPositioningCanvas();
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (positioningState.draggingIndex === null) return;
            
            const pos = getTouchPos(e);
            const index = positioningState.draggingIndex;
            const charData = positioningState.characterImgs[index];
            
            // Allow free movement - characters can be positioned anywhere
            const newX = pos.x - positioningState.dragOffset.x;
            const newY = pos.y - positioningState.dragOffset.y;
            
            // Allow positioning anywhere, but keep at least part of character visible
            const scale = positioningState.scales[index] || 1.0;
            const scaledWidth = charData.originalWidth * charData.baseScale * scale;
            const scaledHeight = charData.originalHeight * charData.baseScale * scale;
            positioningState.positions[index] = {
                x: Math.max(-scaledWidth * 0.8, Math.min(newX, positioningCanvas.width - scaledWidth * 0.2)),
                y: Math.max(-scaledHeight * 0.8, Math.min(newY, positioningCanvas.height - scaledHeight * 0.2))
            };
            
            drawPositioningCanvas();
        }
        
        function updateScaleControls() {
            const container = document.getElementById('scaleControlsContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            transformedCharacters.forEach((char, index) => {
                const scale = positioningState.scales[index] || 1.0;
                const controlDiv = document.createElement('div');
                controlDiv.className = 'scale-control-item';
                controlDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 8px; background: #f8f9fa; border-radius: 8px; min-width: 250px;';
                
                controlDiv.innerHTML = `
                    <label style="font-weight: 500; min-width: 80px;">Character ${index + 1}:</label>
                    <button class="btn btn-sm btn-outline-secondary" onclick="adjustScale(${index}, -0.1)" style="min-width: 40px;">
                        <i class="fas fa-minus"></i>
                    </button>
                    <input type="range" class="form-range" min="0.3" max="2.0" step="0.1" value="${scale}" 
                           oninput="setScale(${index}, parseFloat(this.value))" 
                           style="flex: 1; min-width: 100px;">
                    <button class="btn btn-sm btn-outline-secondary" onclick="adjustScale(${index}, 0.1)" style="min-width: 40px;">
                        <i class="fas fa-plus"></i>
                    </button>
                    <span style="min-width: 45px; text-align: center; font-weight: 500;">${(scale * 100).toFixed(0)}%</span>
                `;
                
                container.appendChild(controlDiv);
            });
        }
        
        function setScale(index, value) {
            if (index >= 0 && index < positioningState.scales.length) {
                positioningState.scales[index] = Math.max(0.3, Math.min(2.0, value));
                drawPositioningCanvas();
                updateScaleControls();
            }
        }
        
        function adjustScale(index, delta) {
            const currentScale = positioningState.scales[index] || 1.0;
            setScale(index, currentScale + delta);
        }
        
        function endDrag() {
            positioningState.draggingIndex = null;
            if (positioningCanvas) {
                positioningCanvas.style.cursor = 'move';
            }
            drawPositioningCanvas();
        }
        
        function handleTouchEnd() {
            endDrag();
        }
        
        function resetCharacterPositions() {
            if (!positioningState.characterImgs.length) return;
            
            const spacing = positioningCanvas.width / (positioningState.characterImgs.length + 1);
            positioningState.characterImgs.forEach((charData, index) => {
                const scale = positioningState.scales[index] || 1.0;
                const scaledWidth = charData.originalWidth * charData.baseScale * scale;
                const scaledHeight = charData.originalHeight * charData.baseScale * scale;
                positioningState.positions[index] = {
                    x: spacing * (index + 1) - scaledWidth / 2,
                    y: positioningCanvas.height - scaledHeight - 50
                };
            });
            drawPositioningCanvas();
        }
        
        function autoArrangeCharacters() {
            if (!positioningState.characterImgs.length) return;
            
            // Arrange characters in a grid or line to avoid overlap
            const cols = Math.ceil(Math.sqrt(positioningState.characterImgs.length));
            const rows = Math.ceil(positioningState.characterImgs.length / cols);
            
            const cellWidth = positioningCanvas.width / cols;
            const cellHeight = positioningCanvas.height / rows;
            
            positioningState.characterImgs.forEach((charData, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const scale = positioningState.scales[index] || 1.0;
                const scaledWidth = charData.originalWidth * charData.baseScale * scale;
                const scaledHeight = charData.originalHeight * charData.baseScale * scale;
                
                positioningState.positions[index] = {
                    x: col * cellWidth + (cellWidth - scaledWidth) / 2,
                    y: row * cellHeight + (cellHeight - scaledHeight) / 2
                };
            });
            drawPositioningCanvas();
        }
        
        function handleBackgroundChange() {
            const backgroundInput = document.getElementById('backgroundInput');
            const backgroundPreview = document.getElementById('backgroundPreview');
            const backgroundImg = document.getElementById('backgroundImg');
            
            if (backgroundInput.files.length > 0) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    backgroundImg.src = e.target.result;
                    backgroundPreview.classList.remove('hidden');
                    
                    // Reinitialize positioning canvas with new background
                    if (transformedCharacters.length > 0) {
                        initPositioningCanvas();
                    }
                };
                reader.readAsDataURL(backgroundInput.files[0]);
            } else {
                backgroundPreview.classList.add('hidden');
                // Reinitialize with default background
                if (transformedCharacters.length > 0) {
                    initPositioningCanvas();
                }
            }
        }

    </script>
</body>
</html>


